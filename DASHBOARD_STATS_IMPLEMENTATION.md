# üìä Dashboard Stats Implementation

## Vue d'ensemble

Le Dashboard a √©t√© mis √† jour pour r√©cup√©rer et afficher correctement toutes les statistiques utilisateur de mani√®re centralis√©e et optimis√©e.

## ‚úÖ Fonctionnalit√©s impl√©ment√©es

### Hook centralis√© : `useDashboardStats`

Un nouveau hook personnalis√© a √©t√© cr√©√© pour g√©rer toutes les statistiques du Dashboard :

**Localisation** : `src/hooks/useDashboardStats.ts`

### Statistiques r√©cup√©r√©es

Le hook `useDashboardStats` centralise et expose les donn√©es suivantes :

```typescript
interface DashboardStats {
  // NFT Stats
  nftCount: number;           // Nombre de NFTs d√©tenus
  hasNFTs: boolean;            // Poss√®de au moins 1 NFT
  
  // Points & Rank
  totalPoints: number;         // Total des points accumul√©s
  globalRank: number | null;   // Classement global (all-time)
  weeklyRank: number | null;   // Classement hebdomadaire
  monthlyRank: number | null;  // Classement mensuel
  
  // Streak Stats
  currentStreak: number;       // Nombre de jours cons√©cutifs
  streakCompleted: boolean;    // Semaine compl√©t√©e
  canClaimToday: boolean;      // Peut claim aujourd'hui
  
  // User Info
  username: string | null;     // Nom d'utilisateur
  walletAddress: string | null; // Adresse wallet MultiversX
}
```

## üèóÔ∏è Architecture

### 1. R√©utilisation des hooks existants

Le hook `useDashboardStats` **r√©utilise** les hooks existants pour √©viter la duplication :

- **`useMyNFTs()`** : Pour r√©cup√©rer le nombre de NFTs
- **`useWeeklyStreak()`** : Pour r√©cup√©rer la streak et son √©tat

### 2. Protection contre les boucles infinies

Le hook utilise plusieurs m√©canismes pour √©viter les appels en boucle :

#### a) Ref pour tracking des fetches
```typescript
const isFetchingRef = useRef(false);
const lastFetchedUserIdRef = useRef<string | null>(null);

// Prevent duplicate fetches
if (isFetchingRef.current && lastFetchedUserIdRef.current === supabaseUserId) {
  if (DEBUG) console.log('üö´ [useDashboardStats] Fetch already in progress, skipping...');
  return;
}
```

#### b) S√©paration des responsabilit√©s
- **`fetchUserStats()`** : R√©cup√®re uniquement les donn√©es de Supabase (profil + ranks)
- **`useEffect` s√©par√©s** : Mettent √† jour les stats NFT/Streak sans refetch

```typescript
// Effect 1: Fetch user stats ONLY when auth changes
useEffect(() => {
  if (isAuthenticated && supabaseUserId) {
    fetchUserStats();
  }
}, [isAuthenticated, supabaseUserId, fetchUserStats]);

// Effect 2: Update NFT stats locally (no refetch)
useEffect(() => {
  setStats(prev => ({ ...prev, nftCount, hasNFTs }));
}, [nftCount, hasNFTs]);

// Effect 3: Update Streak stats locally (no refetch)
useEffect(() => {
  setStats(prev => ({ ...prev, currentStreak, streakCompleted, canClaimToday }));
}, [streakStats?.consecutiveDays, streakStats?.isCompleted, canClaimToday]);
```

#### c) D√©pendances minimales
Le `fetchUserStats` ne d√©pend **que** de :
- `address`
- `isAuthenticated`
- `supabaseUserId`

Il ne d√©pend **PAS** de `nftCount`, `hasNFTs`, `streakStats`, etc. pour √©viter les re-renders en cascade.

### 3. R√©cup√©ration des donn√©es Supabase

Le hook effectue les appels suivants :

```typescript
// 1. Profil utilisateur (username, total_points)
const { data: userProfile } = await supabase
  .from('users')
  .select('username, total_points, wallet_address')
  .eq('id', supabaseUserId)
  .maybeSingle();

// 2. Classements (all-time, weekly, monthly)
const [allTimeRank, weeklyRank, monthlyRank] = await Promise.all([
  getUserRank(supabaseUserId, { type: 'all_time' }),
  getUserRank(supabaseUserId, { type: 'weekly', week, year }),
  getUserRank(supabaseUserId, { type: 'monthly', month, year })
]);
```

### 4. Optimisations

#### a) Cache de 5 minutes
Le hook utilise un syst√®me de cache pour √©viter les appels API inutiles :

```typescript
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

// Cache stock√© en dehors du composant (persiste entre les renders)
const dashboardCache = new Map<string, CachedDashboardData>();

// V√©rification du cache avant fetch
const cached = dashboardCache.get(supabaseUserId);
const now = Date.now();

if (cached && (now - cached.timestamp) < CACHE_DURATION) {
  console.log('üíæ Using cached data (age: ' + Math.round((now - cached.timestamp) / 1000) + 's)');
  // Utiliser les donn√©es en cache
  return;
}

// Sinon, fetch depuis l'API et mettre en cache
const fetchedData = { /* ... */ };
dashboardCache.set(supabaseUserId, {
  ...fetchedData,
  timestamp: Date.now()
});
```

**Avantages** :
- ‚úÖ Pas d'appels API quand on revient sur la page (< 5 min)
- ‚úÖ Affichage instantan√© des stats
- ‚úÖ Cache invalid√© automatiquement apr√®s 5 minutes
- ‚úÖ Cache cleared lors des updates real-time (points, profil)

#### b) Cache et r√©utilisation
- Les hooks `useMyNFTs` et `useWeeklyStreak` ont leur propre cache
- `useLeaderboard` utilise un cache de 5 minutes
- `useDashboardStats` utilise maintenant aussi un cache de 5 minutes
- Pas de duplication des appels API

#### c) Chargement parall√®le
```typescript
// Les 3 classements sont r√©cup√©r√©s en parall√®le
await Promise.all([allTimeRank, weeklyRank, monthlyRank]);
```

#### d) Real-time updates avec invalidation du cache
Le hook s'abonne aux changements en temps r√©el et **invalide le cache** automatiquement :
- **Table `points_transactions`** : Mise √† jour automatique quand l'utilisateur gagne/perd des points
- **Table `users`** : Mise √† jour quand le profil change (username, etc.)

```typescript
// Subscription Supabase Realtime avec cache invalidation
const pointsChannel = supabase
  .channel('dashboard-points-updates')
  .on('postgres_changes', {
    event: '*',
    schema: 'public',
    table: 'points_transactions',
    filter: `user_id=eq.${supabaseUserId}`
  }, () => {
    // 1. Invalider le cache
    dashboardCache.delete(supabaseUserId);
    lastFetchedUserIdRef.current = null;
    
    // 2. Rafra√Æchir les donn√©es
    fetchUserStats();
  })
  .subscribe();
```

**Important** : Le cache est automatiquement invalid√© lors d'√©v√©nements real-time pour garantir la fra√Æcheur des donn√©es.

## üé® Interface Dashboard mise √† jour

### Avant
```typescript
// ‚ùå Donn√©es hardcod√©es
const userData = {
  username: address ? `${address.slice(0, 6)}...${address.slice(-4)}` : 'Guest',
  totalPoints: 1250,
  currentStreak: 5,
  nftCount: 8,
  globalRank: 142
};
```

### Apr√®s
```typescript
// ‚úÖ Donn√©es dynamiques du hook
const { stats, loading, error, refresh } = useDashboardStats();

<StatsCard
  icon="‚≠ê"
  label={t('dashboard.stats.totalPoints')}
  value={loading ? '...' : stats.totalPoints.toLocaleString()}
  variant="gold"
/>
```

## üì¶ Donn√©es affich√©es

| Statistique | Source | Hook utilis√© | Cache |
|------------|--------|--------------|-------|
| **Nombre de NFTs** | MultiversX API | `useMyNFTs()` | Oui (dans le hook) |
| **Total Points** | Supabase `users.total_points` | `useDashboardStats` | **Oui (5 min)** |
| **Classement Global** | Supabase RPC `get_user_rank()` | `useDashboardStats` | **Oui (5 min)** |
| **Classement Weekly** | Supabase RPC `get_user_rank()` | `useDashboardStats` | **Oui (5 min)** |
| **Classement Monthly** | Supabase RPC `get_user_rank()` | `useDashboardStats` | **Oui (5 min)** |
| **Streak Actuelle** | Supabase `week_streaks` | `useWeeklyStreak()` | Oui (dans le hook) |
| **Claim disponible** | Calcul√© depuis streak | `useWeeklyStreak()` | Oui (dans le hook) |
| **Username** | Supabase `users.username` | `useDashboardStats` | **Oui (5 min)** |

## üîÑ Gestion des √©tats

### Loading State
```typescript
<StatsCard
  icon="‚≠ê"
  label={t('dashboard.stats.totalPoints')}
  value={loading ? '...' : stats.totalPoints.toLocaleString()}
/>
```

### Error State
```typescript
{error && (
  <div className="bg-red-500/20 border border-red-500/50 rounded-xl p-4 mb-6">
    <p className="text-[var(--mvx-text-color-primary)] text-sm">
      ‚ö†Ô∏è {t('common.error')}: {error.message}
    </p>
    <Button variant="secondary" onClick={refresh}>
      {t('common.retry')}
    </Button>
  </div>
)}
```

### Empty State
```typescript
// Classement non disponible
value={stats.globalRank ? `#${stats.globalRank}` : t('dashboard.stats.noRank')}
```

## üåç Internationalisation (i18n)

Nouvelles cl√©s de traduction ajout√©es :

### English (`en.json`)
```json
{
  "dashboard": {
    "stats": {
      "noRank": "Unranked",
      "claimAvailable": "Claim available today"
    }
  }
}
```

### French (`fr.json`)
```json
{
  "dashboard": {
    "stats": {
      "noRank": "Non class√©",
      "claimAvailable": "R√©clamation disponible aujourd'hui"
    }
  }
}
```

## üìã Utilisation dans d'autres pages

Le hook `useDashboardStats` peut √™tre r√©utilis√© ailleurs :

```typescript
import { useDashboardStats } from 'hooks/useDashboardStats';

const MyComponent = () => {
  const { stats, loading, error, refresh } = useDashboardStats();
  
  return (
    <div>
      <p>Total Points: {stats.totalPoints}</p>
      <p>NFTs: {stats.nftCount}</p>
      <p>Rank: #{stats.globalRank}</p>
    </div>
  );
};
```

## üöÄ Avantages de cette impl√©mentation

### ‚úÖ Performance
- **Cache intelligent** : Pas de requ√™tes inutiles
- **Chargement parall√®le** : Les classements sont r√©cup√©r√©s simultan√©ment
- **R√©utilisation des hooks** : Pas de duplication des appels API

### ‚úÖ Maintenabilit√©
- **Centralis√©** : Toutes les stats du Dashboard dans un seul hook
- **R√©utilisable** : Peut √™tre utilis√© dans d'autres composants
- **Typ√©** : TypeScript pour la s√©curit√© des types

### ‚úÖ UX
- **Real-time** : Mises √† jour automatiques via Supabase Realtime
- **√âtats clairs** : Loading, error, empty states g√©r√©s
- **Multilingue** : Support EN/FR

### ‚úÖ √âvolutivit√©
- Facile d'ajouter de nouvelles stats
- Facile de modifier les sources de donn√©es
- Facile d'ajouter de nouveaux classements (daily, yearly, etc.)

## üîß Maintenance

### Ajouter une nouvelle statistique

1. **Mettre √† jour l'interface `DashboardStats`**
```typescript
export interface DashboardStats {
  // ... existing stats
  newStat: number; // üëà Nouvelle stat
}
```

2. **R√©cup√©rer la donn√©e dans `fetchUserStats`**
```typescript
const newStatValue = await fetchNewStat(userId);

setStats({
  // ... existing stats
  newStat: newStatValue
});
```

3. **Afficher dans le Dashboard**
```typescript
<StatsCard
  icon="üéØ"
  label="New Stat"
  value={stats.newStat}
/>
```

## ‚ö†Ô∏è Points d'attention

### Authentification
Le hook n√©cessite que l'utilisateur soit authentifi√© :
- `isAuthenticated` doit √™tre `true`
- `supabaseUserId` doit √™tre d√©fini

### D√©pendances
Le hook d√©pend de :
- **AuthContext** : Pour `isAuthenticated` et `supabaseUserId`
- **useMyNFTs** : Pour les NFTs
- **useWeeklyStreak** : Pour la streak
- **Supabase** : Pour les points et classements

### Real-time
Les subscriptions Realtime sont automatiquement nettoy√©es lors du d√©montage du composant.

### Protection contre les boucles infinies
Le hook utilise plusieurs m√©canismes pour √©viter les appels en boucle :
1. **Ref `isFetchingRef`** : Emp√™che les fetches simultan√©s
2. **Ref `lastFetchedUserIdRef`** : V√©rifie si l'user a d√©j√† √©t√© fetch
3. **S√©paration NFT/Streak** : Les stats NFT/Streak sont mises √† jour localement sans refetch
4. **D√©pendances minimales** : `fetchUserStats` ne d√©pend que de l'authentification

## üêõ Probl√®mes r√©solus

### ‚ùå Probl√®me : Boucle infinie d'appels API
**Sympt√¥me** : Les logs montrent des centaines d'appels √† `getUserRank()` en boucle
```
üì° [LeaderboardService] Fetching user rank for all_time leaderboard...
üì° [LeaderboardService] Fetching user rank for weekly leaderboard...
üì° [LeaderboardService] Fetching user rank for monthly leaderboard...
üì° [LeaderboardService] Fetching user rank for all_time leaderboard... (x100)
```

**Cause** : D√©pendances circulaires dans `useEffect`
- `fetchUserStats` d√©pendait de `nftCount`, `hasNFTs`, `streakStats`, `canClaimToday`
- Ces valeurs changent fr√©quemment (hooks `useMyNFTs` et `useWeeklyStreak`)
- Chaque changement recr√©ait `fetchUserStats` ‚Üí d√©clenchait le `useEffect` ‚Üí refetch ‚Üí changement des stats ‚Üí boucle infinie

**Solution** :
1. ‚úÖ **Retirer les d√©pendances NFT/Streak** de `fetchUserStats`
2. ‚úÖ **S√©parer les `useEffect`** : un pour fetch, d'autres pour update local
3. ‚úÖ **Ajouter une ref** `isFetchingRef` pour bloquer les fetches simultan√©s
4. ‚úÖ **Utiliser `setStats(prev => ({...prev}))`** pour update incr√©mentale

### ‚úÖ R√©sultat apr√®s correction

#### Premier chargement (cache vide)
```
üìä [useDashboardStats] Fetching user stats from API for: [userId]
üì° [LeaderboardService] Fetching user rank for all_time leaderboard...
üì° [LeaderboardService] Fetching user rank for weekly leaderboard...
üì° [LeaderboardService] Fetching user rank for monthly leaderboard...
‚úÖ [useDashboardStats] Stats fetched successfully
```

#### Retour sur la page (< 5 minutes)
```
üíæ [useDashboardStats] Using cached data (age: 45s)
```
**Aucun appel API** ! Les donn√©es sont affich√©es instantan√©ment depuis le cache.

#### Retour sur la page (> 5 minutes)
```
üìä [useDashboardStats] Fetching user stats from API for: [userId]
üì° [LeaderboardService] Fetching user rank for all_time leaderboard...
// ... (refetch car cache expir√©)
```

**Une seule fois** lors du chargement initial, puis :
- **Cache pendant 5 minutes** ‚Üí Affichage instantan√©
- **Mises √† jour locales** pour NFT/Streak
- **Invalidation automatique** lors d'√©v√©nements real-time

## üéØ Prochaines √©tapes possibles

1. **Dashboard avanc√©**
   - Graphiques d'√©volution des points
   - Historique des classements
   - Comparaison avec d'autres joueurs

2. **Cache am√©lior√©**
   - IndexedDB pour persistance offline
   - Service Worker pour sync en arri√®re-plan

3. **Notifications**
   - Alertes quand classement change
   - Notifications de nouveaux points

---

**Date de cr√©ation** : 21 octobre 2025  
**Version** : 1.0  
**Statut** : ‚úÖ Impl√©ment√© et fonctionnel

