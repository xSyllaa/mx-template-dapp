# GalacticX - S√©curit√© sans Backend Traditionnel

## üìã Table des Mati√®res
1. [Architecture S√©curis√©e](#architecture-s√©curis√©e)
2. [Comment √ßa fonctionne sans backend ?](#comment-√ßa-fonctionne-sans-backend-)
3. [Row Level Security (RLS)](#row-level-security-rls)
4. [Protection des Routes Frontend](#protection-des-routes-frontend)
5. [Protection des Appels API](#protection-des-appels-api)
6. [Cas d'Usage](#cas-dusage)
7. [Points Critiques de S√©curit√©](#points-critiques-de-s√©curit√©)

---

## Architecture S√©curis√©e

### Stack GalacticX
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         Frontend (React)                ‚îÇ
‚îÇ  - Authentification MultiversX Wallet   ‚îÇ
‚îÇ  - Guards (AdminGuard, AuthGuard)       ‚îÇ
‚îÇ  - Supabase Client (RLS activ√©)         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
               ‚îÇ JWT Token
               ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       Supabase (Backend-as-a-Service)   ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ  PostgreSQL avec RLS              ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Policies par table             ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Validation au niveau DB        ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ  Edge Functions (Deno)            ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Validation serveur             ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Logique m√©tier complexe        ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Principe de D√©fense en Profondeur (Defense in Depth)

**3 Couches de s√©curit√©** :
1. **Frontend Guards** (UX) : Emp√™che l'acc√®s visuel aux pages non autoris√©es
2. **Row Level Security (RLS)** (Database) : **V√âRITABLE S√âCURIT√â** - Emp√™che l'acc√®s aux donn√©es
3. **Edge Functions** (Server-Side) : Validation logique m√©tier complexe

---

## Comment √ßa fonctionne sans backend ?

### ‚ùå Architecture Traditionnelle (avec backend)

```
Frontend ‚Üí Backend API ‚Üí Database
         ‚Üë
    Toute la s√©curit√© ici
```

Probl√®mes :
- Co√ªt de d√©veloppement √©lev√©
- Maintenance complexe
- Besoin de serveurs d√©di√©s

### ‚úÖ Architecture GalacticX (Serverless)

```
Frontend ‚Üí Supabase (PostgreSQL + RLS) + Edge Functions
                    ‚Üë
              S√©curit√© ici !
```

Avantages :
- **RLS = Backend int√©gr√© dans la DB**
- Auto-scaling automatique
- Pas de serveur √† g√©rer
- Co√ªt r√©duit

---

## Row Level Security (RLS)

### Qu'est-ce que RLS ?

RLS (Row Level Security) = **Firewall au niveau des lignes de donn√©es**

**Analogie** : Imaginez une biblioth√®que o√π chaque livre a un cadenas. Seules les personnes autoris√©es (par leur badge JWT) peuvent lire/modifier certains livres.

### Comment √ßa marche ?

#### 1. Authentification MultiversX

```typescript
// L'utilisateur se connecte avec son wallet
const { address } = useGetAccountInfo();

// MultiversX g√©n√®re un JWT token
// Ce token contient : wallet_address, signature, timestamp
```

#### 2. Supabase v√©rifie le JWT

```typescript
// √Ä chaque requ√™te Supabase
const { data, error } = await supabase
  .from('predictions')
  .select('*');

// Supabase extrait le JWT et v√©rifie :
// - Token valide ?
// - Non expir√© ?
// - Signature correcte ?
// ‚Üí auth.uid() = ID de l'utilisateur
```

#### 3. PostgreSQL applique les Policies RLS

```sql
-- Exemple : Table predictions
CREATE POLICY "Only admins can create predictions"
ON predictions FOR INSERT
TO authenticated
WITH CHECK (
  EXISTS (
    SELECT 1 FROM users
    WHERE users.id = auth.uid()  -- ‚Üê Qui est l'utilisateur ?
    AND users.role = 'admin'      -- ‚Üê Est-il admin ?
  )
);
```

**R√©sultat** :
- ‚úÖ Si admin ‚Üí insertion autoris√©e
- ‚ùå Si user ‚Üí **PostgreSQL refuse l'insertion** (m√™me si le frontend essaie)

### Exemples de Policies RLS

#### Exemple 1 : Lecture publique

```sql
-- Tout le monde peut lire les pr√©dictions
CREATE POLICY "Predictions are viewable by everyone"
ON predictions FOR SELECT
TO authenticated
USING (true);  -- ‚Üê Toujours vrai = acc√®s pour tous
```

#### Exemple 2 : √âcriture restreinte √† soi-m√™me

```sql
-- Les utilisateurs peuvent uniquement cr√©er leurs propres pr√©dictions
CREATE POLICY "Users can insert own predictions"
ON user_predictions FOR INSERT
TO authenticated
WITH CHECK (
  user_id = auth.uid()  -- ‚Üê Doit correspondre √† l'utilisateur connect√©
  AND EXISTS (
    SELECT 1 FROM predictions
    WHERE predictions.id = prediction_id
    AND predictions.status = 'open'  -- ‚Üê Validation m√©tier
    AND predictions.close_date > NOW()
  )
);
```

#### Exemple 3 : Admin uniquement

```sql
-- Seuls les admins peuvent valider les r√©sultats
CREATE POLICY "Only admins can update predictions"
ON predictions FOR UPDATE
TO authenticated
USING (
  EXISTS (
    SELECT 1 FROM users
    WHERE users.id = auth.uid()
    AND users.role = 'admin'  -- ‚Üê V√©rification du r√¥le
  )
);
```

---

## Protection des Routes Frontend

### 1. AuthRedirectWrapper

**Objectif** : Rediriger les utilisateurs non connect√©s

```typescript
// src/wrappers/AuthRedirectWrapper/AuthRedirectWrapper.tsx
export const AuthRedirectWrapper = ({ children }: PropsWithChildren) => {
  const isLoggedIn = useGetIsLoggedIn();
  const currentRoute = routes.find((route) => matchPath(route.path, pathname));

  if (!isLoggedIn && currentRoute?.authenticatedRoute) {
    navigate(RouteNamesEnum.home); // ‚Üí Redirection vers home
  }

  return <>{children}</>;
};
```

**Utilit√©** : UX uniquement (l'utilisateur ne voit pas la page)

### 2. AdminGuard

**Objectif** : V√©rifier le r√¥le admin

```typescript
// src/wrappers/AdminGuard/AdminGuard.tsx
export const AdminGuard = ({ children }: PropsWithChildren) => {
  const { isAdmin, loading } = useUserRole();

  if (loading) return <Loader />;

  if (!isAdmin) {
    return <Navigate to={RouteNamesEnum.dashboard} replace />;
  }

  return <>{children}</>;
};
```

**Flux** :
1. L'utilisateur clique sur `/admin`
2. `AdminGuard` appelle Supabase pour r√©cup√©rer `users.role`
3. Si `role !== 'admin'` ‚Üí Redirection vers dashboard

### 3. Configuration des Routes

```typescript
// src/routes/routes.ts
export const routes: RouteWithTitleType[] = [
  {
    path: '/admin',
    title: 'Admin',
    component: Admin,
    authenticatedRoute: true,  // ‚Üê N√©cessite connexion
    adminRoute: true           // ‚Üê N√©cessite r√¥le admin
  }
];
```

```typescript
// src/App.tsx
const PageComponent = route.adminRoute ? (
  <AdminGuard>
    <route.component />
  </AdminGuard>
) : (
  <route.component />
);
```

---

## Protection des Appels API

### ‚ö†Ô∏è Important : Le Frontend n'est PAS s√©curis√© !

**R√®gle d'or** : N'importe qui peut modifier le code JavaScript du navigateur.

```typescript
// ‚ùå MAUVAIS : V√©rification c√¥t√© client uniquement
if (userRole === 'admin') {
  await supabase.from('predictions').insert(newPrediction);
}
// ‚Üí Un utilisateur malin peut bypasser cette v√©rification
```

### ‚úÖ Solution : RLS c√¥t√© Supabase

```typescript
// ‚úÖ BON : Tentative d'insertion (m√™me si role !== 'admin')
const { data, error } = await supabase
  .from('predictions')
  .insert(newPrediction);

// PostgreSQL v√©rifie la policy RLS :
// - Si admin ‚Üí data = nouvelle pr√©diction
// - Si user ‚Üí error = "new row violates row-level security policy"
```

**R√©sultat** :
- Le frontend peut essayer
- **Mais Supabase refuse au niveau de la base de donn√©es**
- **Impossible √† contourner** (sauf piratage de la DB, mais c'est un autre niveau)

### Exemple Concret : Cr√©er une Pr√©diction

#### Frontend (React)

```typescript
// pages/Admin/CreatePrediction.tsx
const handleCreatePrediction = async () => {
  try {
    const { data, error } = await supabase
      .from('predictions')
      .insert({
        competition: 'Premier League',
        home_team: 'Man City',
        away_team: 'Arsenal',
        bet_type: 'result',
        options: [
          { id: '1', label: 'Man City Win', odds: '2.10' },
          { id: 'X', label: 'Draw', odds: '3.50' },
          { id: '2', label: 'Arsenal Win', odds: '3.20' }
        ],
        status: 'open',
        start_date: '2025-10-20T15:00:00Z',
        close_date: '2025-10-20T14:55:00Z',
        points_reward: 100
      });

    if (error) throw error;

    toast.success('Pr√©diction cr√©√©e !');
  } catch (error) {
    console.error(error);
    toast.error('Erreur : Vous devez √™tre admin');
  }
};
```

#### Backend (RLS Policy)

```sql
-- Supabase v√©rifie automatiquement cette policy
CREATE POLICY "Only admins can create predictions"
ON predictions FOR INSERT
TO authenticated
WITH CHECK (
  EXISTS (
    SELECT 1 FROM users
    WHERE users.id = auth.uid()
    AND users.role = 'admin'
  )
);
```

**Si utilisateur non-admin essaie** :
```json
{
  "error": {
    "message": "new row violates row-level security policy for table \"predictions\"",
    "code": "42501"
  }
}
```

---

## Cas d'Usage

### Cas 1 : Utilisateur Normal Soumet une Pr√©diction

**Flux** :
1. User se connecte avec wallet ‚Üí JWT g√©n√©r√©
2. User acc√®de √† `/predictions` ‚Üí AuthRedirectWrapper laisse passer
3. User clique sur "Man City Win" ‚Üí Frontend envoie :
   ```typescript
   supabase.from('user_predictions').insert({
     user_id: auth.uid(),
     prediction_id: 'abc-123',
     selected_option_id: '1'
   })
   ```
4. PostgreSQL v√©rifie RLS policy :
   - `user_id === auth.uid()` ? ‚úÖ
   - Pr√©diction `status = 'open'` ? ‚úÖ
   - `close_date > NOW()` ? ‚úÖ
5. Insertion autoris√©e ‚úÖ

### Cas 2 : Utilisateur Malveillant Essaie de Cr√©er une Pr√©diction

**Flux** :
1. User ouvre la console du navigateur (F12)
2. User essaie de cr√©er une pr√©diction manuellement :
   ```javascript
   await supabase.from('predictions').insert({
     competition: 'Fake League',
     home_team: 'Fake Team A',
     away_team: 'Fake Team B',
     // ...
   })
   ```
3. PostgreSQL v√©rifie RLS policy :
   - `EXISTS (... WHERE role = 'admin')` ? ‚ùå
4. **Insertion refus√©e** ‚ùå avec erreur `42501`

### Cas 3 : Admin Valide un R√©sultat

**Flux** :
1. Admin se connecte ‚Üí JWT avec `role = 'admin'`
2. Admin acc√®de `/admin` ‚Üí AdminGuard v√©rifie le r√¥le ‚úÖ
3. Admin clique "Valider r√©sultat" ‚Üí Edge Function appel√©e :
   ```typescript
   const response = await fetch(
     'https://project.supabase.co/functions/v1/validate-prediction-result',
     {
       method: 'POST',
       headers: {
         'Authorization': `Bearer ${jwt}`,
         'Content-Type': 'application/json'
       },
       body: JSON.stringify({
         prediction_id: 'abc-123',
         winning_option_id: '1'
       })
     }
   );
   ```
4. Edge Function v√©rifie :
   - JWT valide ? ‚úÖ
   - User est admin ? ‚úÖ
   - Logique m√©tier (calcul points, mise √† jour leaderboard) ‚úÖ
5. R√©sultat valid√© ‚úÖ

---

## Points Critiques de S√©curit√©

### ‚úÖ Ce qui EST s√©curis√©

1. **Donn√©es sensibles** :
   - Impossible de lire les pr√©dictions des autres users
   - Impossible de modifier les points d'un autre user
   - Impossible de cr√©er des pr√©dictions sans √™tre admin

2. **Logique m√©tier** :
   - Impossible de soumettre apr√®s `close_date`
   - Impossible de soumettre 2 fois la m√™me pr√©diction
   - Impossible de valider un r√©sultat sans √™tre admin

3. **Int√©grit√© de la DB** :
   - Contraintes CHECK (statut, r√¥le)
   - Foreign keys
   - UNIQUE constraints

### ‚ö†Ô∏è Ce qui N'EST PAS s√©curis√© (et c'est normal)

1. **Code Frontend** :
   - N'importe qui peut voir le code React
   - N'importe qui peut modifier le JavaScript
   - ‚Üí **Mais √ßa ne donne pas acc√®s aux donn√©es !**

2. **Cl√©s API publiques** :
   - `VITE_SUPABASE_ANON_KEY` est visible
   - ‚Üí **C'est normal !** Cette cl√© est con√ßue pour √™tre publique
   - ‚Üí La s√©curit√© vient des RLS policies, pas de la cl√©

3. **Guards Frontend** :
   - `AdminGuard` peut √™tre bypass√© (en manipulant le code)
   - ‚Üí **Mais Supabase refusera quand m√™me l'action !**

### üõ°Ô∏è R√®gles d'Or

1. **Toujours activer RLS** sur toutes les tables
2. **Toujours valider c√¥t√© serveur** (RLS ou Edge Functions)
3. **Ne jamais faire confiance au frontend** pour la s√©curit√©
4. **Utiliser les Guards** pour l'UX, pas pour la s√©curit√©
5. **Tester les policies RLS** en essayant de contourner les restrictions

---

## R√©sum√© : Qui fait quoi ?

| Composant | R√¥le | S√©curit√© ? |
|-----------|------|-----------|
| **Frontend Guards** | Emp√™che affichage UI | ‚ùå Contournable |
| **RLS Policies** | Emp√™che acc√®s donn√©es | ‚úÖ **V√âRITABLE S√âCURIT√â** |
| **Edge Functions** | Logique m√©tier complexe | ‚úÖ S√©curis√© |
| **MultiversX Wallet** | Authentification | ‚úÖ Signature cryptographique |
| **Supabase JWT** | Identification utilisateur | ‚úÖ Token sign√© |

---

## Conclusion

**Sans backend traditionnel, GalacticX est-il s√©curis√© ?**

‚úÖ **OUI**, car :
1. **Supabase = Backend int√©gr√©** (PostgreSQL + RLS)
2. **RLS = Firewall au niveau des lignes**
3. **Impossible de contourner** sans pirater la DB elle-m√™me
4. **Frontend = UX uniquement**, pas de s√©curit√©

**Le frontend peut mentir, mais la base de donn√©es ne ment jamais.** üõ°Ô∏è

